<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CentOS 安装与配置 ShadowSocks 服务端]]></title>
    <url>%2Farchives%2Fshadowsocks.html</url>
    <content type="text"><![CDATA[前言随着 “净网2018” 专项整治行动的开展，鉴于近期墙内形式的严峻，搜索 ShadowSocks 安装教程也很难搜到了。恰逢近期亚太一区的网络状态堪忧，安装教程找半天，思来想去索性就自己写一篇博文，方便以后自己安装。安装ShadowSocks，中文名影梭，使用socks5代理，在中国大陆广泛用于翻墙，速度比 pptp 和 OpenVPN 要快，是一款翻墙必备神器。安装 pip安装 ShadowSocks 首先要安装 pip。Pip 是安装 python 包的工具，提供了安装包，列出已经安装的包，升级包以及卸载包的功能。Pip 是对 easy_install 的取代，提供了和 easy_install 相同的查找包的功能，因此可以使用 easy_install 安装的包也同样可以使用 pip 进行安装。yum install python-setuptools &amp;&amp; easy_install pip安装 ShadowSockspip install shadowsocks创建配置文件 /etc/shadowsocks.jsontouch /etc/shadowsocks.jsonvi /etc/shadowsocks.json修改配置文件为如下配置：单用户&#123; "server": "0.0.0.0", "server_port": 8388, "local_address": "127.0.0.1", "local_port": 1080, "password": "your-password", "timeout": 300, "method": "rc4-md5", "fast_open": false&#125;多用户&#123; "server": "0.0.0.0", "local_address": "127.0.0.1", "local_port": 1080, "port_password": &#123; "8989": "password0", "9001": "password1", "9002": "password2", "9003": "password3", "9004": "password4" &#125;, "timeout": 300, "method": "rc4-md5", "fast_open": false&#125;上述配置文件各字段的含义：1.server：服务器 IP (IPv4/IPv6)，注意这也将是服务端监听的 IP 地址server_port：监听的服务器端口local_address：服务端本地监听的 IP 地址local_port：服务端本地端口password：用来加密的密码timeout：超时时间（秒）method：加密方式，官方默认使用 aes-256-cfb，推荐使用 rc4-md5，RC4 比 AES 速度快好几倍fast_open：是否快速启动，true 或 false启动服务ssserver -c /etc/shadowsocks.json -d start #启动ssserver -c /etc/shadowsocks.json -d stop #停止官方的单用户配置，多用户配置。客户端下载地址附上各客户端的下载地址shadowsocks-winGitHubShadowsocks-Qt5GitHubOutline WindowsGitHubDirect DownloadCommand-line Clientpip install shadowsocksShadowsocksX-NGGitHubOutline macOSGitHubApp StoreCommand-line Clientpip install shadowsocksbrew install shadowsocks-libevcpan Net::ShadowsocksShadowsocks-Qt5GitHubCommand-line Clientpip install shadowsocksapt-get install shadowsocks-libevcpan Net::ShadowsocksOutline AndroidDirect DownloadGitHubPlay Storeshadowsocks-androidGoogle PlayGoogle Play-BetaWingyApp StoreMobileShadowSocksBig BossOutline iOSGitHubApp Storeshadowsocks-libevopkg install shadowsocks-libevshadowsocks-libev-polarsslopkg install shadowsocks-libev-polarssl官网地址（需要翻墙）：https://shadowsocks.org/en/download/clients.html]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>ShadowSocks</tag>
        <tag>CentOS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 兼容 Let’s Encrypt 证书]]></title>
    <url>%2Farchives%2FJava_compatible_certificate_of_Lets_Encrypt.html</url>
    <content type="text"><![CDATA[最近公司打算将网站 HTTPS 证书更换为 Let’s Encrypt 的证书。虽然现在主流浏览器已经信任 Let’s Encrypt 证书了，但是对于一些 Java 老版本，还是会出现不兼容的情况。为解决此问题，本文应运而生。什么是 Let’s EncryptLet’s Encrypt 是一个免费，自动化和开放的证书颁发机构（CA），为公益而运行，由 Internet Security Research Group（ISRG） 提供服务。Let’s Encrypt 由 Mozilla、Cisco、Akamai、IdenTrust、EFF 等组织人员发起，主要的目的是为了推进网站从 HTTP 向 HTTPS 过度的进程，目前已经有越来越多的商家加入和赞助支持，其证书现在已经可以被所有主流的浏览器所信任。证书兼容性因 Let’s Encrypt 证书较新，下列 JDK/JRE 旧版本会不信任 Let’s Encrypt 证书（查看 Java 版本：命令行输入 java -version ）：Java 7 &lt; 7u111Java 8 &lt; 8u101而抛出以下异常：javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException[... 以下输出省略 ...]详细兼容性问题参考：https://letsencrypt.org/docs/certificate-compatibility/检查 Java 环境是否兼容 Let’s Encrypt 证书自行编写程序测试自行编写测试程序查看 Java 环境是否支持 Let’s Encrypt 证书：new URL("https://helloworld.letsencrypt.org").openConnection().connect();然后查看是否抛出以下异常即可：javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException[... 以下输出省略 ...]使用 SSLPing 进行测试如还没有测试程序，可以使用 ping 测试程序：SSLPing（可测试任何 SSL/TLS 端口，不仅是 HTTPS）。下面将使用预先编译的 SSLPing.jar 进行测试（阅读源码后自行编译也非常容易）：在命令行输入以下内容以克隆 SSLPing 这个项目（请确保已安装 git）或点击链接下载 SSLPing.jargit clone https://github.com/dimalinux/SSLPing.git成功后进行测试：java -jar SSLPing/dist/SSLPing.jar helloworld.letsencrypt.org 443然后查看是否抛出以下异常即可：About to connect to 'helloworld.letsencrypt.org' on port 443javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException[... 以下输出省略 ...]问题解决出现这种证书不兼容的情况，只是因为 Let’s Encrypt 证书太新，Java 老版本未将其加入根证书导致。具体解决办法有两种共三个：1.更新 Java update 版本比如 JDK8_8u100，升级到 JDK8_8u101 及以上就可以了。但是搞 Java 的都是老学究，怕出现兼容问题，坚决不肯升级，所以不推荐。2.自行将 Let’s Encrypt 证书加入信任Chrome 浏览器打开一个使用 Let’s Encrypt 证书的网站：https://chengww.com，可以看到一共有三个证书：现在关键是将哪个证书加入信任的问题。参考 Let’s Encrypt 官网 Chain of Trust 里面的这段说明：Our roots are kept safely offline. We issue end-entity certificates to subscribers from the intermediates in the next section.根证书 ISRG Root X1 (self-signed) 是离线安全保存的，在下一节中向中间人发放终端实体证书。IdenTrust has cross-signed our intermediates. This allows our end certificates to be accepted by all major browsers while we propagate our own root.Under normal circumstances, certificates issued by Let’s Encrypt will come from “Let’s Encrypt Authority X3”. The other intermediate, “Let’s Encrypt Authority X4”, is reserved for disaster recovery and will only be used should we lose the ability to issue with “Let’s Encrypt Authority X3”. The X1 and X2 intermediates were our first generation of intermediates. We’ve replaced them with new intermediates that are more compatible with Windows XP.IdenTrust 和 Let’s Encrypt 中间证书已经交叉签名，故所有主流浏览器都接受 Let’s Encrypt 的结束证书。正常情况下，Let’s Encrypt 颁发的证书将来自“Let’s Encrypt Authority X3”。另一个中间件“Let’s Encrypt Authority X4”保留用于灾难恢复，只有在Let’s Encrypt 失去发出“Let’s Encrypt Authority X3”的能力时才会使用。X1和X2中间体是Let’s Encrypt 的第一代中间体。Let’s Encrypt 用与Windows XP更兼容的新中间体替换它们。也就是现在只有 Let’s Encrypt Authority X3 是正在签名用的。将其加入信任即可。参考解决方法（任选其一）：往 JRE 中导入 Let’s Encrypt 证书（无需修改代码，推荐）可以将 Let’s Encrypt 证书加入 JRE 的信任证书，这种方式无需修改代码，简单快捷，推荐使用。操作系统为 Mac OS X 或 Linux检查 JAVA_HOME 已经正确配置在终端上输入以下内容：echo $JAVA_HOME出现以下类似回应即为正确配置：/Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents/Home/如未配置请自行搜索配置 Java 环境变量即可。下载 Let’s Encrypt 中间证书wget https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem或直接复制上述链接下载即可导入证书keytool -trustcacerts -keystore &quot;$JAVA_HOME/jre/lib/security/cacerts&quot; -storepass changeit -noprompt -importcert -alias lets-encrypt-x3-cross-signed -file &quot;lets-encrypt-x3-cross-signed.pem&quot;出现Certificate was added to keystore即可（注：当出现 java.io.FileNotFoundException… 时可能要检查相关文件路径是否正确）操作系统为 Windows检查 JAVA_HOME 已经正确配置在命令行上输入以下内容：echo %JAVA_HOME%出现以下类似回应即为正确配置：C:\Program Files (x86)\Java\jdk1.8.0_92如未配置请自行搜索配置 Java 环境变量即可。下载 Let’s Encrypt 中间证书wget https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem或直接复制上述链接下载即可导入证书cd %JAVA_HOME%\binkeytool -trustcacerts -keystore &quot;%JAVA_HOME%\jre\lib\security\cacerts&quot; -storepass changeit -noprompt -importcert -alias lets-encrypt-x3-cross-signed -file &quot;lets-encrypt-x3-cross-signed.pem&quot;出现Certificate was added to keystore ``` 即可**（注：当出现 java.io.FileNotFoundException... 时可能要检查相关文件路径是否正确）**该方法至此已经完成，请检测是否成功。---### 程序运行时添加 Let&apos;s Encrypt 证书为信任证书也可以在程序初始化或网络初始化时将 Let&apos;s Encrypt 证书添加进信任证书。使用火狐浏览器访问 [https://helloworld.letsencrypt.org](https://helloworld.letsencrypt.org) ，然后将 **Let&apos;s Encrypt Authority X3** 导出为 **.cer** 文件，或点击下载 [Let&apos;s Encrypt Authority X3.cer](https://lets-encrypt.pek3a.qingstor.com/Let&apos;s%20Encrypt%20Authority%20X3.cer)将文件地址替换下述文件地址中： **&quot;Let&apos;s Encrypt Authority X3.cer&quot;**具体请参考以下示例添加:```Java/** * Created by chengww on 2018/9/18. */import java.io.IOException;import java.net.URL;import java.net.URLConnection;import javax.net.ssl.SSLHandshakeException;public class SSLExample &#123; private static void initTrustManager() &#123; // Enter the path of the file named &apos;Let&apos;s Encrypt Authority X3.cer&apos; System.setProperty(&quot;javax.net.ssl.trustStore&quot;, &quot;Let&apos;s Encrypt Authority X3.cer&quot;); &#125; public static void main(String[] args) throws IOException &#123; initTrustManager(); // signed by default trusted CAs. testUrl(new URL(&quot;https://www.thawte.com&quot;)); // signed by letsencrypt testUrl(new URL(&quot;https://helloworld.letsencrypt.org&quot;)); // signed by LE&apos;s cross-sign CA testUrl(new URL(&quot;https://letsencrypt.org&quot;)); // qingstorage testUrl(new URL(&quot;https://stor.qingstorage.com&quot;)); // qingcloud testUrl(new URL(&quot;https://www.qingcloud.com/&quot;)); // self-signed testUrl(new URL(&quot;https://www.pcwebshop.co.uk/&quot;)); &#125; static void testUrl(URL url) throws IOException &#123; URLConnection connection = url.openConnection(); try &#123; connection.connect(); System.out.println(&quot;Headers of &quot; + url + &quot; =&gt; &quot; + connection.getHeaderFields()); &#125; catch (SSLHandshakeException e) &#123; System.out.println(&quot;Untrusted: &quot; + url); &#125; &#125;&#125;该方法至此已经完成，请检测是否成功。升级 JDK/JRE 版本可以直接升级的 JDK/JRE update 版本，7u111 及 8u101 之后已将 Let’s Encrypt 证书加入信任。前往 https://www.oracle.com/technetwork/java/javase/downloads/index.html 下拉到最后一项 Java Archive，点击 DOWNLOAD选择 Accept License Agreement，下载对应的 JDK/JRE 版本后安装即可该方法至此已经完成，请检测是否成功。检查是否成功重复操作上述 检查 Java 环境是否兼容 Let’s Encrypt 证书 的内容即可。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Let’s Encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VCD--国产专利之痛]]></title>
    <url>%2Farchives%2FVCD-Chinese_patent_pain.html</url>
    <content type="text"><![CDATA[世界上第一台家用VCD机，影音光碟（Video Compact Disc；VCD）诞生于中国合肥的”万燕”之手，”万燕”让中国的老百姓认识了VCD，并开创了中国的VCD行业。VCD在二十世纪末消费类电子领域里，是中国可能领先的唯一机会，而在此之前本领域没有一个中国人创造并形成产业。但是当时万燕集团的掌门人、也是VCD机研制者姜万勐先生犯下令他后悔终生的致命错误：他竟然认为在当时的情况，申不申请专利没有太大的意义，以致万燕推出的第一批1000台VCD机，几乎都被国内外家电公司买去做了样机，成为解剖的对象。随后，索尼、松下、飞利浦等国外制造业巨大纷纷加强对VCD机的研究，推出新的专利技术，刷新VCD的技术标准，以致包括万燕集团在内的国内家电企业生产VCD需要向这些国外巨头缴纳巨额的专利费用，在之后的七八年时间里，这些专利费用在国内市场就累积上百亿之多。仅仅3到4年时间，拥有这项领先技术的万燕却最终淹没于同行业的激烈竞争中。而VCD产业，随着进入者的增多，产品利润被不断摊薄，最后这项没什么技术含量的产业，也在低价竞争中日薄西山，被DVD蚕食殆尽。VCD的前世今生起源世界上第一台VCD视盘机是由国人姜万勐先生发明的，诞生于安徽万燕公司。事情发生在1992年。在美国举办的国际广播电视技术展览会上。美国C-CUBE（斯高柏）公司曾展出了一项图像解压缩技术。时任安徽观代集团总经理的姜万勐先生受其启发， 敏锐地意识到：可以把图像和声音存储在一张比较小的光盘里的MPEG技术，意味着可以创造出一种物美价廉的视听产品，供老百姓在家中使用。于是在1993年，出资57万元，研制出了物美价廉的VCD（价格相比同期录像机很有优势）。同年12月，他又与美籍华人孙燕生（时任C-CUBE公司董事长）共同投资1700万美元成立了万燕公司，各取了姜万勐、孙燕生名字中的一个字作为公司名称：安徽省万燕电子系统有限公司。但是令人匪夷所思的是，VCD真正的核心技术：万燕公司花费巨资委托C-CUBE研发的解码芯片技术，却牢牢掌握在C-CUBE斯高柏微系统公司手里。这为后来国产VCD乱局埋下了崩溃的种子。万燕的危机在1993年安徽现代电视技术研究所的VCD可行性报告中，有这样的一段描述：这是本世纪末消费类电子领域里，中国可能领先的惟一机会。为此，姜万勐进行了一系列的市场调查，得到了一系列的数字：1993年中国市场上组合音响的销售量是142万台，录像机的销售量是170余万台，LD影碟机100万台，CD激光唱机是160余万台。当时的LD光盘是四五百元一张，而VCD机的光盘价格却只有它的10％左右，因此可以预测，VCD机每年的销售量将会达到200万台左右。第一批VCD中国的老百姓到了1994年底才逐渐认识VCD。在这一年，万燕生产了几万台VCD机。不仅如此，姜万勐还要开发碟片，总不能让老百姓买了枪而没子弹。为此，他又向11家音像出版社购买了版权，推出了97种卡拉OK碟片。在最初成立不到一年的时间里，“万燕”倾其所有，开创了一个市场，确立了一个响当当的品牌，并形成了一整套成型的技术，独霸于VCD天下。可以说，万燕的初创是成功的，也是辉煌的。但是，万燕也给自己酿下一杯苦酒。令姜万勐感到伤心的是，万燕推出的第一批1000台VCD机，几乎都被国内外各家电公司买去做了样机，成为解剖的对象。1994年，万燕开始批量生产VCD，但初期由于片源不配套，使VCD在市场发展上停滞了很长的一段时间。万燕所面临的难题是软硬件要一齐开发。“万燕”在前期研究开发的投入是1600万美元，广告投入是2000万元人民币，中国百姓到了1994年底才逐渐认识VCD，而在这一年，“万燕”生产了几万台VCD，结果只卖出了2万台。由于前期投入太多，导致早期产品成本高达每台360美元，再加广告费用，在市场上每台VCD卖四五千元，却基本无利可赚。 不仅如此，万燕还要开发碟片，万燕为此又向11家音像出版社购买版权，推出97种卡拉OK碟片。投入上亿地研发资金，产品研发出来，却没有及时申请专利，进行技术垄断。其他制造商只需要花费极小的代价就能获得成套的成熟生产技术。在前期的产品成本上，万燕公司就吃了大亏；接下来的败招是九四年就投入2000万的广告费用。一直到九五年。影碟机市场还属于培育阶段，在盗版影碟大量涌现之前，影碟机的市场容量很有限。投入再多地广告费都不会起到预期地效果。广告是需要连续进行投入的商业行为，一旦中断，广告就会随着时间地延长而变得毫无效果。要是将2000万广告预算拖到95下半年再投入，或许能让万燕公司起死回生。万燕前期投入上亿的研究资金、2000万的广告费用，迄今为止卖出去地台影碟机还没超过两万台，就算每台影碟机的售价高达四千元，万燕收回成本都困难，更不要说什么利润了。万燕资金裢脱节了！万燕公司在影碟机市场启动的前夜就花光了所有钱，陷入生存的危机之中。万燕要打翻身仗，唯有继续筹集资金扩大产能，等到九五、九六年影碟机市场突然暴发的时候，利用先机大举抢占市场。万燕会成功的筹集到资金吗？显然不会，不然万燕就不会是被遗忘的品牌了。在盗版影碟大量出现之前，影碟机的惨淡市场、万燕的惨淡经营已经让投资人失出信心。最重要的一点就是引入影碟机整套的生产技术甚至不需要一百万的资金，然而投资万燕却要分摊万燕公司前期投入研发的上亿元成本，哪个投资人会傻到做这折本的买卖？市场蜂拥，万燕沉没1996年开始到1997年，中国的VCD市场每年以数倍的速度增长。从1995年的60万台猛增至1996年600多万台，1997年销售达到1000万台。只用了短短5年，VCD影碟机累计销售已有5000万台，并催生了爱多、步步高、新科等国内响当当的品牌。但 “万燕”却在这个产业中，从“先驱”成为“先烈”，其市场份额从100％跌到2％，也就在这一年，“万燕”被同省的美菱集团重组，成为美菱万燕公司。“万燕”让中国百姓认识了VCD，但摘桃子的却是深谙市场秘诀的广东人。 此时，深谙市场秘诀的广东人却恰到好处地把握了这个良机。由于VCD整机组装对技术要求不高，没有生产许可证的限制，再加上市场已经被打开，广东又是散件水货的聚集地，几个因素凑到一起，VCD组装厂如雨后春笋般出现在了珠江三角洲。“床板工厂”开始遍布大街小巷，一个人一天可以组装10台、20台，一家老少一天就能装出几十台，市场颇为火爆。在中国家电产品中，没有一种产品如VCD 般以狂飙突进的方式席卷全国。“万燕”从市场上衰落后，VCD进入了爆炸式的增长时期，有关统计显示，中国VCD企业最多的时候达1000多家，整个VCD行业风云变幻,其铺天盖地的广告攻势，高开低走的价格走势，大起大落的市场命运，无不让人刻骨铭心。待续…中国VCD发展历程1993年9月，留美学者姜万勐、孙燕生生产出世界上第一台VCD。1996年至1997年，爱多、新科等新品牌开始大规模进入市场，并占据VCD大部分市场。1998年9月，发生了全国性的SVCD与CVD标准之争论。1998年8月，信息产业部制定《超级VCD系统行业规范》，于1998年11月1日生效。1998年10月至1999年7月，各大影碟机厂家不断推出附加新技术的VCD产品，如可播放MP3和MIDI的超级VCD，掌上型超级VCD和可录写的超级VCD。甚至实现了VCD联网和语音复读等功能，以实现中小学的VCD辅助教学。1999年1月，影碟机行业广告费投入直线下降。在激烈竞争中，不少知名企业陷入困境，如“小霸王”倒闭和“爱多”亏损严重。1999年7月，各主要生产厂家不约而同地开始大规模降价，普通单碟机的价格纷纷跌破800元/台。DVD产品开始取代VCD。本文综合以下文章整理：万燕VCD的衰败之路(20110629)https://wenku.baidu.com/view/d203a14469eae009581bec16.html万燕VCD的悲剧http://www.360doc.com/content/16/0512/15/14771698_558528759.shtml中国VCD行业案例分析https://wenku.baidu.com/view/69283f040740be1e650e9a2a.html]]></content>
      <categories>
        <category>科技随笔</category>
      </categories>
      <tags>
        <tag>VCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写给产品经理之前端是如何展示后端数据的]]></title>
    <url>%2Farchives%2FHow_does_the_front_end_display_the_back-end_data.html</url>
    <content type="text"><![CDATA[移动互联网的迅猛发展让移动APP呈现出爆发之势，这两年更是移动开发程序员的春天。今天的互联网上充斥着产品与技术的撕逼。也许你会问产品经理到底要不要懂技术？由此引申出，产品经理到底要不要懂设计？产品经理到底要不要懂运营？产品经理到底要不要懂市场？产品经理到底要不要懂业务？这所有问题的来源都是大家对于产品经理的工作认识不一致。每个人心中都有一个产品经理的定义，产品经理在技术方面更多的是去统筹和规划。不是画画图写写文档就可以了。这里面更多的需要的是对逻辑的梳理和拆分。例如很简单的一个app内嵌发红包的活动，产品经理需要确定整个活动的流程。从用户进入页面的那一瞬间就应该被产品经理掌控。他的每一个步骤，每一个操作会带来什么结果，有哪些变量会导致活动进程失败，这些都要产品去考虑。等到活动逻辑和过程全部梳理完成，下面就要进行拆分了。还是以发红包为例，红包中金额是客户端写死还是服务端进行计算，红包领取资格需要服务端返回几种结果，每种结果对应客户端的提示是什么，用户领取红包以后服务端需要记录那些信息（帐号，uid，领取时间，金额，是否使用等），客户端哪些地方需要加入计数器进行数据统计。总结起来其实就是，产品经理需要根据开发的每一个环节，将所有内容分类整理，并分发给不同部分的开发进行研发。最后，还需要给测试准备好check list，当测试按照check list测试完成以后，才可以上线。以上种种都需要产品对前端如何显示后端数据有一个清晰的认识才能规划好数据如何展示。是APP写死呢还是后台返回，在用户任务进行的时候有哪些可能case。只有搞清楚这些，产品才能在实际的开发中掌握好整个项目的流程与进展，才能不被开发给糊弄。1.前后端到底在干些什么简单的说，前端仅仅将后端返回的数据展示在页面上，不做过多的逻辑处理。前端需要关心的是，数据如何更好的展示出来，页面效果如何做出来，以及其性能问题。而后端就是负责对这些数据进行处理，提供给前端展示。前端一般有H5、android、ios等多端界面。数据不要轻易写死在前端里面，不然到时候三端都要修改，费时费力。而将这些变化多数据让后端进行处理，前端将这个数据取出来显示出来就行了。举个例子吧，下图是一个美团app首页团购的展示效果上方美食等8个icon一般为固定展示栏目，非特殊情况不会修改。那么前端一般是写死在app中，等到需要更新的时候更新app即可。而下方猜你喜欢是一个列表，该列表数据经常变化，数据写在服务端维护，app取出数据进行展示即可。2.前端到底是怎么显示数据的首先，前段对页面的展示是分两步走的。第一、在本地绘制好界面，当然此时未连api会填充一些假数据，或写一些默认值。第二、连api进行数据获取，将数据填充进界面。既然如此，咱们简单看下前端拿到的数据到底长什么样的吧。现在前端获取到的数据基本是json数据。何谓json数据JSON是一种传递对象的语法，对象可以是name/value对，数组和其他对象。拿刚才美团截图里面的猜你喜欢列表简单说下吧，如下面这一坨东西就是后端可能返回给前端的数据&#123; &quot;list&quot;: [ &#123; &quot;title&quot;: &quot;合辑护甲&quot;, &quot;content&quot;: &quot;【北京市】奥斯卡货到付款...&quot; &quot;price&quot;: 12.9 &quot;distance&quot;: &quot;145.0km&quot; &#125;, &#123; &quot;title&quot;: &quot;合辑护甲&quot;, &quot;content&quot;: &quot;【北京市】奥斯卡货到付款...&quot; &quot;price&quot;: 12.9 &quot;distance&quot;: &quot;145.0km&quot; &#125; ] &#125;不需要特别懂里面每一个的含义，只需要知道，前端通过”title”这个键名(key)就可以拿到”合辑护甲”这个值(value)。&quot;title&quot;: &quot;合辑护甲&quot; 这一整个就是俗称的一个字段。通过该字段前端就可以获取到列表的标题了。当然这个列表只是简单的展示用，还有诸如图片地址、优惠信息、已售份额等信息没有提供，这就是缺少字段的情况。前后端就是通过这样的一个定义获取/传递数据的。3.什么样的数据该由前端来控制，什么样的数据该由后端提供呢考虑到后期拓展、需求变更等，一般来说，涉及到计算的、可能有变动的，一律不要让前端来弄。还是刚才那个例子，在刚才那个列表中有一个“立减5元”的橙黄色tag。这个tag信息，如果考虑不充分，比如说，后端只提供一个数字5，然后前端在其页面写死“立减x元”，x为填入后端提供的数字，颜色固定为橙黄色。这个如果需求不修改还好，如果后期需要新增一个“满20减5元”的红色tag不傻眼了吗？到时候只能通过升级app来解决，而且不升级的老用户将永远看不到这个红色的tag。所以说，考虑到程序的可复用和拓展性，需要产品将后期可能新增或变更的需求考虑好，和前后端进行沟通，让前后端设计好实现，尽量降低程序的耦合和硬编码。这才能使一个产品更加健壮以及让苦逼的程序猿少加班的关键。那么刚才那个tag的需求如何设计才合理呢？首先是tag显示文字，全权由后端提供，可以是多个字段，由前端进行拼接。然后是tag的颜色，提供几种样式让前端判断是一种可行的办法，但是直接提供tag的色值给前端的这种方式无疑给前端展示增加了无限的可能。是不是也要增加一个tag形状的字段呢？俗话说，过犹不及。tag形状这种东西真的很少变更，字段太多无疑会增加开发的时间成本，而且会让人有一种舍本逐末之感。4.前端数据刷新时机问题前端获取到后端数据后，如果前端不主动刷新重新请求数据的话，这个页面的数据在该页面销毁前会一直保持不变。如何理解？首先，第一次进入一个页面，该页面数据为空或默认数据。此时前端会链接api请求数据。数据请求完成后，填充进页面。那么本次联网请求就完成了，在前端不进行二次数据请求之前，该页面会一直保持本次请求的数据。也就是说，就算服务端修改了数据，前端此时是不能事实的进行更新的，因为我前端不知道你数据更新了。那么在这个需要实时更新页面数据的时候和前端讲这种需求会被前端直接回绝：“做不了”。这个时候产品咋办，怪怪妥协？最后背锅的还是自己，而且自己也不知道是真做不了还是假做不了。实时刷新也不是不能做，只是做的成本略高，需要和后端进行配合，像微信聊天一样和后端进行长连接(socket)，这样服务端数据变更前端就知道数据变更了。当然如果稍懂页面刷新机制的话，可以要求前端在适当的时机进行页面刷新，如在页面可见的时候进行刷新，这样用户每次看到的都是最新的数据。也可以让用户主动刷新，如新增刷新功能。5.One more thing产品懂技术这件事情，不仅会降低和开发同学沟通时的难度和被歧视风险，还会提升在面对开发同学意见时的判断力，会降低被技术团队忽悠的几率。同时，在需要向上级解释技术原因导致变更的情况下，也会有助于说服老板。“闻道有先后，术业有专攻”，要相信自己所接触的开发团队是专业的，靠谱的，相信开发团队为实现需求所做出的技术方案是合理的，最优的。如果有质疑，可以加深沟通，以合适的方式提出自己的质疑。这里要补充一句的是，这个信任过程是需要建立的，也是会根据团队的表现不断变化的；同理，其实团队对于产品经理的信任度也是一样的情况。吐槽是没有意义的，关键还是要解决问题。如果觉得产品经理不靠谱，那么有没有进行过深入的沟通？如果觉得开发不好沟通，那么有没有进行过了解，不好沟通的原因在哪里？如果当事人本身确实不可沟通，那么有没有考虑和对方的老板沟通，或者通过自己的老板如实反映情况？吐槽是最容易的，解决问题反而会很难。]]></content>
      <categories>
        <category>给产品经理讲技术</category>
      </categories>
      <tags>
        <tag>给产品经理讲技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用JAVA合并哔哩哔哩手机客户端下载的视频]]></title>
    <url>%2Farchives%2FJava_merge_videos_of_bilibili.html</url>
    <content type="text"><![CDATA[前言使用哔哩哔哩手机客户端下载的视频在电脑上播放，无奈视频是分段的，每次都只好手动的合并再播放。而且客户端下载的视频不会按网页文件名命名，而是以av号–全数字命名。最可怕的是，每次打开一集的时候，进入的目录层级得吓死人。最最可怕的是，新版客户端默认文件后缀是 .blv 。难道我们要一个一个重命名然后再合并吗？NO！这种重复的事情交给计算机就好了。自己动手丰衣足食，我们就动手写个JAVA版的哔哩哔哩视频合并小程序。完整项目地址: http://git.oschina.net/chengww5217/BiliBiliMerge直接下载使用:http://git.oschina.net/chengww5217/BiliBiliMerge/raw/master/run/BilibiliMeroV1.2.7z使用帮助:http://git.oschina.net/chengww5217/BiliBiliMerge/blob/master/README.md实现功能1.自动识别文件夹下视频文件并进行合并2.合并后以视频播放页视频名称+视频分 P 名称命名F:(日剧)夺爱之冬\第一话.flv3.合并完成删除源文件前期准备1.得到哔哩哔哩客户端下载的视频目录将哔哩哔哩手机客户端下载的视频移出手机的 Android 目录，如移动到根目录因 Android MTP 限制，电脑无法访问 Android 目录。此目录是 Android 应用缓存目录。视频位于 Android–data–tv.danmaku.bili(最下面)–download 下。如图显示的数字目录即为需求目录。请将数字目录移出Android目录外。手机连上电脑后，将上述数字目录复制或移动到电脑。2.分析视频目录结构8896746\1\entry.json 这个json包含了整个播放目录的名称和每一P的名称8896746\1\lua.flv.bili2api.3 .blv 这个文件夹就是各分段视频文件了。注意：视频文件命名逻辑是：0.blv,1.blv…9.blv,10.blv…也就是说，一旦视频文件超过 10 个，如 0-10，合并的时候会出现这样的合并顺序：0.blv–1.blv–10.blv–2.blv… 所以说，我们需要先把 0.blv-9.blv 重命名为 00.blv-09.blv3.FLV科普FLV是一个二进制文件，由文件头（FLV header）和很多tag组成。tag又可以分成三类：audio,video,script，分别代表音频流，视频流，脚本流（关键字或者文件信息之类）。FLV文件=FLV头文件+ tag1+tag内容1 + tag2+tag内容2 + …+… + tagN+tag内容N。也就是说合并FLV分段视频的时候不能简单粗暴的将多个flv视频片段按字节流的方式写到一个文件中。这时候来看FLV合并的原理：（1） flv 文件由1个header和若干个tag组成；（2） header记录了视频的元数据；（3） tag 是有时间戳的数据；（4） flv合并的原理就是把多个文件里的tag组装起来，调整各tag的时间戳。（5）判断是否为第一个文件，是则安装头部。了解了这些就可以动手撰写我们的合并程序了。Let’s go.流程逻辑提示输入哔哩哔哩下载的视频文件夹(输入文件夹)，输入输出的文件夹。因最后合并完成后要删除源文件，故要求输出文件夹不能和输入文件夹相同。一次输入多个输入文件夹以英文逗号隔开。然后进入输入文件夹下– entry.json 得到视频名称，和输入文件夹拼接创建目录。如：输出到 F:\视频名称 文件夹执行合并listFiles()执行两次进入到这个文件夹entry.json 得到视频每一P的名称，拼接输出如 F:\视频名称\第一话.flv判断进入 lua.flv.bili2api.3 文件夹即可得到所有视频文件判断对 0.flv-9.flv 进行重命名—&gt; 00.flv-09.flv进行合并操作删除源文件程序1.首先eclipse建项目包结构很简单2.输入输出文件夹包含main方法的Bilibili.java输入输出文件夹 File out;File[] in = null;while(true)&#123; boolean isBreak = true; Scanner scanner = new Scanner(System.in); String line = scanner.nextLine(); if(line == null || line.length() == 0)&#123; System.out.println("输入不为空，请重试："); isBreak = false; &#125;else&#123; String[] lines = line.split(","); in = new File[lines.length]; for(int i = 0;i &lt; lines.length;i++)&#123; in[i] = new File(lines[i]); if(!in[i].exists())&#123; System.out.println(in[i].getAbsolutePath() + "文件夹不存在，请重试："); isBreak = false; break; &#125; &#125; &#125; if(isBreak)&#123; break; &#125;&#125;System.out.println("请输入输出路径：");while(true)&#123; Scanner scanner = new Scanner(System.in); String line = scanner.nextLine(); out = new File(line); if(!out.exists())&#123; System.out.println("文件夹不存在，请重试："); &#125;else&#123; boolean isEquals = true; for(int i = 0;i &lt; in.length;i++)&#123; if(out.getAbsolutePath().equals(in[i].getAbsolutePath()))&#123; isEquals = false; System.out.println("输出路径和某个输入路径相同，请重试："); break; &#125; &#125; if(isEquals)&#123; break; &#125; &#125;&#125;3.循环读取多个输入目录的视频名称//循环 for(int i = 0;i &lt; in.length;i++)&#123; //得到播放文件名，如"(日剧)夺爱之冬" String path = in[i].getAbsolutePath() +separator+ "1"+separator+"entry.json"; String line = null; try &#123; BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(path), Charset.forName("utf-8"))); line = reader.readLine(); reader.close(); System.out.println("json="+line); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //输出路径 String[] names = tool.json_getName(line); String episode_path = out.getAbsolutePath() + separator + names[0]; File episode = new File(episode_path); if(!episode.exists())&#123; episode.mkdirs(); &#125; System.out.println("输出："+episode_path); //合并 tool.doMerge(in[i], episode_path); &#125;4.判断对 0.flv-9.flv 进行重命名—&gt; 00.flv-09.flv 后合并public void doMerge(File in,String episode_path)&#123; //1、2、3、4... File[] files = in.listFiles(); //循环 for(File f : files)&#123; //文件名，如第一话 String name = null; //获得所有名为.blv的文件 File[] ffs = null; File[] fs = f.listFiles(); for(final File ff : fs)&#123; if(ff.getName().equals(&quot;entry.json&quot;))&#123; String json_name = null; try &#123; BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(ff), Charset.forName(&quot;utf-8&quot;))); json_name = reader.readLine(); reader.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; name = json_getName(json_name)[1]; &#125; if(ff.isDirectory() &amp;&amp; ff.getName().startsWith(&quot;lua.&quot;))&#123; //重命名 for(int i = 0; i &lt; ff.list().length;i++)&#123; File pathname = ff.listFiles()[i]; //0.blv -- 00.blv if(pathname.getName().endsWith(&quot;.blv&quot;) &amp;&amp; pathname.getName().length() == 5)&#123; pathname.renameTo(new File(pathname.getParentFile().getAbsolutePath() + File.separator + &quot;0&quot; + i + &quot;.blv&quot;)); &#125; if(pathname.getName().endsWith(&quot;.flv&quot;) &amp;&amp; pathname.getName().length() == 5)&#123; pathname.renameTo(new File(pathname.getParentFile().getAbsolutePath() + File.separator + &quot;0&quot; + i + &quot;.flv&quot;)); &#125; //0.blv.bdl -- 00.blv.bdl if(pathname.getName().endsWith(&quot;.blv.bdl&quot;) &amp;&amp; pathname.getName().length() == 9)&#123; pathname.renameTo(new File(pathname.getParentFile().getAbsolutePath() + File.separator + &quot;0&quot; + i + &quot;.blv.bdl&quot;)); &#125; &#125; ffs = ff.listFiles(new FileFilter() &#123; public boolean accept(File pathname) &#123; for(int i = 0;i &lt; ff.list().length;i++)&#123; if(pathname.getName().endsWith(&quot;.blv&quot;) || pathname.getName().endsWith(&quot;.flv&quot;) || pathname.getName().endsWith(&quot;.blv.bdl&quot;))&#123; return true; &#125; &#125; return false; &#125; &#125;); //合并 System.out.println(&quot;开始合并...&quot;); FlvMerge mFlvMerge = new FlvMerge(); try &#123; mFlvMerge.merge(ffs, new File(episode_path + File.separator + name + &quot;.flv&quot;)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;5.递归删除操作public boolean deleteFolder(File file)&#123; if(!file.exists())&#123; return false; &#125; if(file.isFile() || file.listFiles().length == 0)&#123; file.delete(); return true; &#125;else&#123; File[] files = file.listFiles(); for(int i=0;i&lt;files.length;i++)&#123; deleteFolder(files[i]); &#125; file.delete(); return true; &#125; &#125;6.具体怎么对FLV视频进行合并的，请点击这里 ，注释比较清晰。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Bilibili</tag>
        <tag>FlvMerge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓指纹+密码支付(解锁)仿支付宝Demo]]></title>
    <url>%2Farchives%2FPersional_Android_fingerprint_useage.html</url>
    <content type="text"><![CDATA[1.前言Google从Android6.0（api23）就开始提供标准指纹识别支持，并对外提供指纹识别相关的接口。但是Android上的指纹识别似乎就是用来解锁手机屏幕，三方APP应用指纹的也是寥寥无几。一直想踩下安卓指纹识别的坑，直到这两天终于空出时间来尝试下android指纹识别的应用。好吧，废话说不下去了，直接上Demo截图：2.使用指纹识别点击指纹识别button，弹出如图弹窗，弹窗使用DialogFragment。具体实现请看下面3.使用密码解锁指纹识别的使用官方标准库Google提供的与指纹识别相关的核心类不多，主类是FingerprintManager，主类依赖三个内部类，如下图所示：FingerprintManager主要提供三个方法如下：FingerprintManager.AuthenticationCallback类提供的回调接口如下，重点区分红色下划线标注的部分启动指纹识别接口看了上面的介绍，如果要写代码就变得简单了1. AndroidManifest权限声明&lt;uses-permission android:name=&quot;android.permission.USE_FINGERPRINT&quot;/&gt;2. 获取FingerManager服务对象public static FingerprintManager getFingerprintManager(Context context) &#123; FingerprintManager fingerprintManager = null; try &#123; fingerprintManager = (FingerprintManager)context.getSystemService(Context.FINGERPRINT_SERVICE); &#125; catch (Throwable e) &#123; Log.e(&quot;TAG&quot;,&quot;have not class FingerprintManager&quot;); &#125; return fingerprintManager;&#125;3. 启动指纹识别mFingerprintManager.authenticate(cryptoObject, mCancellationSignal, 0, mAuthCallback, null);官方v4兼容包上面介绍最标准的官方实现指纹识别的方式，当然适配肯定没这么简单，因为有很多设备兼容性要考虑，Google后续再v4包中提供了一套完整的实现，实现类与上面的一一对应的，就是改了个名字（FingerprintManager改为了FingerprintManagerCompat，机智的发现Compat是兼容的意思，所以Google在v4包中做了一些兼容性处理），做了很多兼容处理，官方推荐使用后者。v4包中类结构如下：v4包中的类使用与上面标准库中的一致，就是名字不一样而已，这里不再介绍使用方式。3.使用密码解锁指纹识别失败达到一定次数调用密码解锁，同指纹识别弹窗一样使用DialogFragment。用这个DialogFragment有个坑，稍后再讲。密码解锁弹窗样式，fragment_pwd.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="40dp" android:layout_marginRight="40dp" android:layout_marginTop="100dp" android:background="@drawable/shape_dialog" android:orientation="vertical" android:paddingBottom="@dimen/spacing_large"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;TextView style="@style/style_black_normal_text" android:layout_width="wrap_content" android:layout_height="@dimen/text_item_height" android:layout_centerInParent="true" android:gravity="center" android:text="请输入密码" /&gt; &lt;ImageView android:id="@+id/iv_close" android:layout_width="20dp" android:layout_height="20dp" android:background="@drawable/selector_item_pressed" android:layout_alignParentRight="true" android:layout_centerVertical="true" android:layout_marginRight="@dimen/spacing_tiny" android:src="@mipmap/icon_del" /&gt; &lt;/RelativeLayout&gt; &lt;View style="@style/style_separate_line" /&gt; &lt;com.chengww.fingerdemo.PwdView android:id="@+id/pwdView" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="@dimen/spacing_large" android:layout_marginRight="@dimen/spacing_large" android:background="@color/white" /&gt; &lt;TextView android:id="@+id/tv_miss_pwd" style="@style/style_blue_normal_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="@dimen/text_item_right_margin" android:layout_marginEnd="@dimen/text_item_right_margin" android:layout_marginRight="@dimen/text_item_right_margin" android:text="忘记密码?" android:background="@drawable/selector_item_pressed" android:layout_gravity="end" android:gravity="center" /&gt; &lt;/LinearLayout&gt; &lt;com.chengww.fingerdemo.InputMethodView android:id="@+id/inputMethodView" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentBottom="true" /&gt;&lt;/RelativeLayout&gt;密码显示圆点框public class PwdView extends View &#123; private ArrayList&lt;String&gt; result;//输入结果保存 private int count;//密码位数 private int size;//默认每一格的大小 private Paint mBorderPaint;//边界画笔 private Paint mDotPaint;//掩盖点的画笔 private int mBorderColor;//边界颜色 private int mDotColor;//掩盖点的颜色 private RectF mRoundRect;//外面的圆角矩形 private int mRoundRadius;//圆角矩形的圆角程度 public PwdView(Context context) &#123; super(context); init(null); &#125; private InputCallBack inputCallBack;//输入完成的回调 private InputMethodView inputMethodView; //输入键盘 public interface InputCallBack &#123; void onInputFinish(String result); &#125; public PwdView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(attrs); &#125; public PwdView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(attrs); &#125; /** * 初始化相关参数 */ void init(AttributeSet attrs) &#123; final float dp = getResources().getDisplayMetrics().density; this.setFocusable(true); this.setFocusableInTouchMode(true); result = new ArrayList&lt;&gt;(); if (attrs != null) &#123; TypedArray ta = getContext().obtainStyledAttributes(attrs, R.styleable.PwdView); mBorderColor = ta.getColor(R.styleable.PwdView_border_color, Color.LTGRAY); mDotColor = ta.getColor(R.styleable.PwdView_dot_color, Color.BLACK); count = ta.getInt(R.styleable.PwdView_count, 6); ta.recycle(); &#125; else &#123; mBorderColor = Color.LTGRAY; mDotColor = Color.GRAY; count = 6;//默认6位密码 &#125; size = (int) (dp * 30);//默认30dp一格 //color mBorderPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mBorderPaint.setStrokeWidth(3); mBorderPaint.setStyle(Paint.Style.STROKE); mBorderPaint.setColor(mBorderColor); mDotPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mDotPaint.setStrokeWidth(3); mDotPaint.setStyle(Paint.Style.FILL); mDotPaint.setColor(mDotColor); mRoundRect = new RectF(); mRoundRadius = (int) (5 * dp); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int w = measureWidth(widthMeasureSpec); int h = measureHeight(heightMeasureSpec); int wsize = MeasureSpec.getSize(widthMeasureSpec); int hsize = MeasureSpec.getSize(heightMeasureSpec); //宽度没指定,但高度指定 if (w == -1) &#123; if (h != -1) &#123; w = h * count;//宽度=高*数量 size = h; &#125; else &#123;//两个都不知道,默认宽高 w = size * count; h = size; &#125; &#125; else &#123;//宽度已知 if (h == -1) &#123;//高度不知道 h = w / count; size = h; &#125; &#125; setMeasuredDimension(Math.min(w, wsize), Math.min(h, hsize)); &#125; private int measureWidth(int widthMeasureSpec) &#123; //宽度 int wmode = MeasureSpec.getMode(widthMeasureSpec); int wsize = MeasureSpec.getSize(widthMeasureSpec); if (wmode == MeasureSpec.AT_MOST) &#123;//wrap_content return -1; &#125; return wsize; &#125; private int measureHeight(int heightMeasureSpec) &#123; //高度 int hmode = MeasureSpec.getMode(heightMeasureSpec); int hsize = MeasureSpec.getSize(heightMeasureSpec); if (hmode == MeasureSpec.AT_MOST) &#123;//wrap_content return -1; &#125; return hsize; &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123;//点击控件弹出输入键盘 requestFocus(); inputMethodView.setVisibility(VISIBLE); return true; &#125; return true; &#125; @Override protected void onFocusChanged(boolean gainFocus, int direction, Rect previouslyFocusedRect) &#123; super.onFocusChanged(gainFocus, direction, previouslyFocusedRect); if (gainFocus) &#123; inputMethodView.setVisibility(VISIBLE); &#125; else &#123; inputMethodView.setVisibility(GONE); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); final int width = getWidth() - 2; final int height = getHeight() - 2; //先画个圆角矩形 mRoundRect.set(0, 0, width, height); canvas.drawRoundRect(mRoundRect, 0, 0, mBorderPaint); //画分割线 for (int i = 1; i &lt; count; i++) &#123; final int x = i * size; canvas.drawLine(x, 0, x, height, mBorderPaint); &#125; //画掩盖点, // 这是前面定义的变量 private ArrayList&lt;Integer&gt; result;//输入结果保存 int dotRadius = size / 8;//圆圈占格子的三分之一 for (int i = 0; i &lt; result.size(); i++) &#123; final float x = (float) (size * (i + 0.5)); final float y = size / 2; canvas.drawCircle(x, y, dotRadius, mDotPaint); &#125; &#125; @Override public boolean onCheckIsTextEditor() &#123; return true; &#125; @Override public InputConnection onCreateInputConnection(EditorInfo outAttrs) &#123; outAttrs.inputType = InputType.TYPE_CLASS_NUMBER;//输入类型为数字 outAttrs.imeOptions = EditorInfo.IME_ACTION_DONE; return new MyInputConnection(this, false); &#125; public void setInputCallBack(InputCallBack inputCallBack) &#123; this.inputCallBack = inputCallBack; &#125; public void clearResult() &#123; result.clear(); invalidate(); &#125; private class MyInputConnection extends BaseInputConnection &#123; public MyInputConnection(View targetView, boolean fullEditor) &#123; super(targetView, fullEditor); &#125; @Override public boolean commitText(CharSequence text, int newCursorPosition) &#123; //这里是接受输入法的文本的，我们只处理数字，所以什么操作都不做 return super.commitText(text, newCursorPosition); &#125; @Override public boolean deleteSurroundingText(int beforeLength, int afterLength) &#123; //软键盘的删除键 DEL 无法直接监听，自己发送del事件 if (beforeLength == 1 &amp;&amp; afterLength == 0) &#123; return super.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL)) &amp;&amp; super.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_DEL)); &#125; return super.deleteSurroundingText(beforeLength, afterLength); &#125; &#125; /** * 设置输入键盘view * * @param inputMethodView */ public void setInputMethodView(InputMethodView inputMethodView) &#123; this.inputMethodView = inputMethodView; this.inputMethodView.setInputReceiver(new InputMethodView.InputReceiver() &#123; @Override public void receive(String num) &#123; if (num.equals("-1")) &#123; if (!result.isEmpty()) &#123; result.remove(result.size() - 1); invalidate(); &#125; &#125; else &#123; if (result.size() &lt; count) &#123; result.add(num); invalidate(); ensureFinishInput(); &#125; &#125; &#125; &#125;); &#125; /** * 判断是否输入完成，输入完成后调用callback */ void ensureFinishInput() &#123; if (result.size() == count &amp;&amp; inputCallBack != null) &#123;//输入完成 StringBuffer sb = new StringBuffer(); for (String i : result) &#123; sb.append(i); &#125; inputCallBack.onInputFinish(sb.toString()); clearResult(); &#125; &#125; /** * 获取输入文字 * * @return */ public String getInputText() &#123; if (result.size() == count) &#123; StringBuffer sb = new StringBuffer(); for (String i : result) &#123; sb.append(i); &#125; return sb.toString(); &#125; return null; &#125;&#125;下方输入键盘public class InputMethodView extends LinearLayout implements View.OnClickListener &#123; private InputReceiver inputReceiver; public InputMethodView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); LayoutInflater.from(context).inflate(R.layout.view_password_input, this); initView(); &#125; private void initView() &#123; findViewById(R.id.btn_1).setOnClickListener(this); findViewById(R.id.btn_2).setOnClickListener(this); findViewById(R.id.btn_3).setOnClickListener(this); findViewById(R.id.btn_4).setOnClickListener(this); findViewById(R.id.btn_5).setOnClickListener(this); findViewById(R.id.btn_6).setOnClickListener(this); findViewById(R.id.btn_7).setOnClickListener(this); findViewById(R.id.btn_8).setOnClickListener(this); findViewById(R.id.btn_9).setOnClickListener(this); findViewById(R.id.btn_0).setOnClickListener(this); findViewById(R.id.btn_del).setOnClickListener(this); findViewById(R.id.layout_hide).setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; setVisibility(GONE); &#125; &#125;); &#125; @Override public void onClick(View v) &#123; String num = (String) v.getTag(); this.inputReceiver.receive(num); &#125; /** * 设置接收器 * @param receiver */ public void setInputReceiver(InputReceiver receiver)&#123; this.inputReceiver = receiver; &#125; /** * 输入接收器 */ public interface InputReceiver&#123; void receive(String num); &#125;&#125;MainActivity实现输入回调就可以得到回调结果了public class MainActivity extends AppCompatActivity implements PwdView.InputCallBack&#123; @Override public void onInputFinish(String result) &#123; if (result.equals("123456")) &#123; fragment.dismiss(); Toast.makeText(this, "验证成功", Toast.LENGTH_SHORT).show(); &#125;else &#123; showPwdError(); &#125; &#125;&#125;今天暂时写这么多吧，整个项目还有点BUG，标题说仿支付宝也仿的不像，改天把后半部分整理出来修改下再发个完整版的。源代码下载：http://git.oschina.net/chengww5217/fingerdemo指纹解锁部分参考引用了以下文章，原作者指纹识别部分写的非常棒，强烈建议前往拜读：http://www.cnblogs.com/popfisher/p/6063835.htmlhttps://willowtreeapps.com/ideas/android-fingerprint-apis-an-overview-for-android-app-developers/]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>FingerManager</tag>
        <tag>指纹识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio上传代码到码云(Oschina)教程]]></title>
    <url>%2Farchives%2FAndroid_studio_push_to_oschina.html</url>
    <content type="text"><![CDATA[前言git 代码仓库一般是用的 github。但由于国内的情况，不进行科学上网的话那个速度简直是龟速。再加上公司那个 10M 的小水管实在是带不动，以及付费创建私有项目等，只好转战国内的代码托管站点。我一直使用的都是 oschina，但是有个问题。Android studio 的 VCS 工具一直上传不了代码，总是被拒绝。今天终于搞清楚了是怎么回事，教程请往下看。教程1.首先前往码云注册账号，没什么好说的，全中文的。2.码云右上方加号，创建项目这个默认使用Readme初始化项目。如果你不使用任何文件初始化你的项目，即不勾选下图所有的复选框，那么就不会有冲突问题了。也就是和上传到GitHub一样，完全不会被拒绝。以下教程以使用 Readme 初始化项目为例，教大家如何将项目上传到码云，也同样适用于解决分支冲突的问题。3.完成后，和上传到 github 步骤一样打开 Android Studio–VCS–Enable Version Control Integration…下拉选择 git然后仓库就创建好了，此时左方文件应显示为红色然后 VCS–git–add 代码添加到 git 仓库有提示是否将 vcs.xml （版本控制的配置文件） 也一并加入到仓库，这个随意。右上 commit changescommit and push 或者 commit 然后再 push 也是一样项目界面复制仓库地址，填写仓库地址，填写 oschina 用户名密码。第一次需要设定一个密码，以后无需登录，直接输入密码即可。然后 push 等待被拒绝VCS–git–pull（看清楚不是 push）拉取 Readme.md进行拉取 Readme.md 操作前，一定要把本地 git 仓库未 commit 的文件 commit。因进行 VCS 操作后，android studio 会自动添加 vcs.xml 等文件到 git。刷新按钮，刷新出 master 勾选–pull如果出现提示 fatal: refusing to merge unrelated histories 不能合并不同的仓库的提示，请前往你项目的文件夹，右键 Git Base here.输入 git pull origin master --allow-unrelated-histories 回车，等待合并拉取到Readme.md，关闭窗口。下方 VersionControl 可以看到 readme.md 已经被拉取再次push就可以了刷新oschina仓库地址，大功告成]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>oschina</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闪烁加载视图---ShimmerRecyclerView]]></title>
    <url>%2Farchives%2FShimmerRecyclerView.html</url>
    <content type="text"><![CDATA[今天看到一个和支付宝加载RecyclerView显示加载中动画类似的库，感觉很有意思，参照官网说明写一个粗浅的使用说明给大家分享下。具体的显示效果如下：List DemoGrid Demo项目简介ShimmerRecyclerView一个自定义循环视图，带有shimmer视图，用来表现视图正在加载中。这个循环视图有一个内置的适配器来控制shimmer性能并提供两个方法：showShimmerAdapter() - 设置一个demo(加载中)适配器，显示预设子demo视图的数量。hideShimmerAdapter() -隐藏加载中视图，恢复适配器以显示实际的子元素.属性和方法按如下属性和方法初始化demo视图.XML 属性Java 方法Explanationapp:demo_child_countsetDemoChildCount(int)在shimmer适配器中展现设置demo视图的数量(Integer)。app:demo_layoutsetDemoLayoutReference(int)定义my_demo_view.xml ,请参考布局[1]。app:demo_layout_manager_typesetDemoLayoutManager(LayoutManagerType)演示视图布局管理。[1] 一个显示List Demo的 my_demo_view.xml（加载中） 的例子：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;4dp&quot; android:layout_marginLeft=&quot;16dp&quot; android:layout_marginRight=&quot;16dp&quot; android:layout_marginTop=&quot;4dp&quot; android:background=&quot;@drawable/bg_card&quot; android:orientation=&quot;vertical&quot; &gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;16dp&quot; android:background=&quot;@android:color/white&quot; android:orientation=&quot;horizontal&quot; android:paddingLeft=&quot;8dp&quot; android:paddingRight=&quot;8dp&quot;&gt; &lt;LinearLayout android:layout_width=&quot;0dp&quot; android:layout_height=&quot;78dp&quot; android:layout_weight=&quot;1&quot; android:orientation=&quot;vertical&quot; android:paddingLeft=&quot;8dp&quot; &gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;6dp&quot; android:layout_marginBottom=&quot;3dp&quot; android:alpha=&quot;0.1&quot; android:background=&quot;@android:color/background_dark&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;6dp&quot; android:layout_marginBottom=&quot;3dp&quot; android:layout_marginTop=&quot;3dp&quot; android:alpha=&quot;0.1&quot; android:background=&quot;@android:color/background_dark&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;6dp&quot; android:layout_marginBottom=&quot;3dp&quot; android:layout_marginTop=&quot;3dp&quot; android:alpha=&quot;0.1&quot; android:background=&quot;@android:color/background_dark&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;6dp&quot; android:layout_marginBottom=&quot;3dp&quot; android:layout_marginTop=&quot;3dp&quot; android:alpha=&quot;0.1&quot; android:background=&quot;@android:color/background_dark&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;6dp&quot; android:layout_marginBottom=&quot;3dp&quot; android:layout_marginTop=&quot;3dp&quot; android:alpha=&quot;0.1&quot; android:background=&quot;@android:color/background_dark&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;6dp&quot; android:layout_marginBottom=&quot;3dp&quot; android:layout_marginTop=&quot;3dp&quot; android:alpha=&quot;0.1&quot; android:background=&quot;@android:color/background_dark&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;6dp&quot; android:layout_marginTop=&quot;3dp&quot; android:alpha=&quot;0.1&quot; android:background=&quot;@android:color/background_dark&quot; /&gt; &lt;/LinearLayout&gt; &lt;View android:layout_width=&quot;78dp&quot; android:layout_height=&quot;78dp&quot; android:layout_marginLeft=&quot;8dp&quot; android:layout_marginRight=&quot;8dp&quot; android:alpha=&quot;0.1&quot; android:background=&quot;@android:color/background_dark&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;16dp&quot; android:layout_marginLeft=&quot;16dp&quot; android:layout_marginRight=&quot;16dp&quot; android:orientation=&quot;vertical&quot; &gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;6dp&quot; android:layout_marginBottom=&quot;3dp&quot; android:layout_marginTop=&quot;6dp&quot; android:alpha=&quot;0.1&quot; android:background=&quot;@android:color/background_dark&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;6dp&quot; android:layout_marginBottom=&quot;3dp&quot; android:layout_marginTop=&quot;3dp&quot; android:alpha=&quot;0.1&quot; android:background=&quot;@android:color/background_dark&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;6dp&quot; android:layout_marginBottom=&quot;3dp&quot; android:layout_marginTop=&quot;3dp&quot; android:alpha=&quot;0.1&quot; android:background=&quot;@android:color/background_dark&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;[1.1] @drawable/bg_card:&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;corners android:radius=&quot;3dp&quot; /&gt; &lt;solid android:color=&quot;@android:color/white&quot; /&gt; &lt;stroke android:width=&quot;1dp&quot; android:color=&quot;#d6d6d6&quot; /&gt;&lt;/shape&gt;使用方法1.将本库添加到你的项目中在你的项目级build.gradle文件中添加下列设置：allprojects &#123; repositories &#123; ... maven &#123; url &apos;https://jitpack.io&apos; &#125; &#125;&#125;module下build.gradle文件中添加依赖：dependencies &#123; compile &apos;com.github.sharish:ShimmerRecyclerView:v1.0&apos;&#125;2.定义你的xml:&lt;com.cooltechworks.views.shimmer.ShimmerRecyclerViewxmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;android:id=&quot;@+id/shimmer_recycler_view&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;app:demo_child_count=&quot;10&quot;app:demo_grid_child_count=&quot;2&quot;app:demo_layout=&quot;@layout/layout_demo_grid&quot;app:demo_layout_manager_type=&quot;grid&quot; /&gt;@layout/layout_demo_grid指在加载spinner时展现的示例布局(参考[1])。3.在你的Activity onCreate()方法中，初始化shimmer如下：ShimmerRecyclerView shimmerRecycler = (ShimmerRecyclerView) findViewById(R.id.shimmer_recycler_view);shimmerRecycler.setLayoutManager(layoutManager);shimmerRecycler.setAdapter(mAdapter);//显示加载中shimmerRecycler.showShimmerAdapter();4.耗时操作后显示真正要显示的内容，然后隐藏加载中：shimmerRecycler.hideShimmerAdapter();其余操作和RecyclerView一样，要完成上拉加载下拉刷新，点击事件等同RecyclerView可以在Adapter中完成。项目官网地址：https://github.com/sharish/ShimmerRecyclerView]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ShimmerRecyclerView</tag>
      </tags>
  </entry>
</search>
